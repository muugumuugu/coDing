<link href="/styles/home.css" rel="stylesheet">
<p>{{data structure}}<code></code>
A &nbsp; <code>set</code> &nbsp;is a collection of elements, without duplicates and without order.<code></code>
<code></code>
<code></code>
<br>Task:<code></code>
Show each of these set operations:<code></code>
<code></code></p>
<ul>
<li>Set creation<code></code></li>
<li>Test m &isin; S -- "m is an element in set S"<code></code></li>
<li>A &cup; B -- <code>union</code>; a set of all elements either in set A or in set B.<code></code></li>
<li>A &cap; B -- <code>intersection; a set of all elements in both</code> set A and set B.<code></code></li>
<li>A &#x2216; B -- <code>difference</code>; a set of all elements in set A, except those in set B.<code></code></li>
<li>A &sube; B -- <code>subset</code>; true if every element in set A is also in set B.<code></code></li>
<li>A = B -- <code>equality</code>; true if every element of set A is in set B and vice versa.<code></code>
<code></code>
<br><code></code>
As an option, show some other set operations.<code></code>
<br>(If A &sube; B, but A &ne; B, then A is called a true or proper subset of B, written A &sub; B or A &#x228a; B.)<code></code>
<code></code>
As another option, show how to modify a mutable set.<code></code>
<code></code>
<code></code>
One might implement a set using an <a href="associative array">associative array</a> (with set elements as array keys and some dummy value as the values).<code></code>
<code></code>
One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).<code></code>
<code></code>
The basic test, m &isin; S, is <a href="O">O</a>(n) with a sequential list of elements, O(<code>log</code> n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.<code></code>
<code></code>
<code></code>
{{Template:See also lists}}<code></code>
<br><br><code></code></li>
</ul>