<link href="/styles/home.css" rel="stylesheet">
<p><a href="WP:K-means%2B%2B|K-means++ clustering]] a classification of data, so that points assigned to the same cluster are similar (in some sense).  It is identical to the <a href="[WP:K-means_clustering|K-means]] algorithm, except for the selection of initial conditions.  [[Image:CircleClusters.png|thumb|right|alt=A circular distribution of data partitioned into 7 colored clusters; similar to the top of a beach ball|This data was partitioned into 7 clusters using the [[WP:K-means_clustering|K-means algorithm]].">WP:K-means%2B%2B|K-means++ clustering]] a classification of data, so that points assigned to the same cluster are similar (in some sense).  It is identical to the [[WP:K-means<em>clustering|K-means]] algorithm, except for the selection of initial conditions.  [[Image:CircleClusters.png|thumb|right|alt=A circular distribution of data partitioned into 7 colored clusters; similar to the top of a beach ball|This data was partitioned into 7 clusters using the [[WP:K-means</em>clustering|K-means algorithm]">[WP:K-means<em>clustering|K-means]] algorithm, except for the selection of initial conditions.  [[Image:CircleClusters.png|thumb|right|alt=A circular distribution of data partitioned into 7 colored clusters; similar to the top of a beach ball|This data was partitioned into 7 clusters using the [[WP:K-means</em>clustering|K-means algorithm]].">WP:K-means%2B%2B|K-means++ clustering]] a classification of data, so that points assigned to the same cluster are similar (in some sense).  It is identical to the [[WP:K-means<em>clustering|K-means]] algorithm, except for the selection of initial conditions.  [[Image:CircleClusters.png|thumb|right|alt=A circular distribution of data partitioned into 7 colored clusters; similar to the top of a beach ball|This data was partitioned into 7 clusters using the [[WP:K-means</em>clustering|K-means algorithm]</a>.</a><code></code>
<code></code>
The task is to <code><code>implement the K-means++ algorithm</code></code>.  Produce a function which takes two arguments: the number of clusters K, and the dataset to classify.  K is a positive integer and the dataset is a list of points in the Cartesian plane.  The output is a list of clusters (related sets of points, according to the algorithm).<code></code>
<code></code>
For <code><code>extra credit</code></code> (in order):<code></code></p>
<h1 id="provideafunctiontoexerciseyourcodewhichgeneratesalistofrandompointsc5c">Provide a function to exercise your code, which generates a list of random points.<code></code></h1>
<h1 id="provideavisualizationofyourresultsincludingcentroidsseeexampleimagec6c">Provide a visualization of your results, including centroids (see example image).<code></code></h1>
<h1 id="generalizethefunctiontopolarcoordinatesinradiansc7c">Generalize the function to polar coordinates (in radians).<code></code></h1>
<h1 id="generalizethefunctiontopointsinanarbitrarynspaceieinsteadofxypairspointsareanntuplesrepresentingcoordinatesinsupnsupbrifthisisdifferentormoredifficultthantheahrefnaivenaiveasolutionforsup2supdiscusswhathadtochangetosupportndimensionsc8c">Generalize the function to points in an arbitrary N space (i.e. instead of x,y pairs, points are an N-tuples representing coordinates in ℝ<sup>N</sup>). <BR><code>If this is different or more difficult than the <a href="naive">naive</a> solution for ℝ<sup>2</sup>, discuss what had to change to support N dimensions.</code><code></code></h1>
<p><code></code>
Extra credit is only awarded if the examples given demonstrate the feature in question. To earn credit for 1. and 2., visualize 6 clusters of 30,000 points in ℝ<sup>2</sup>.  It is not necessary to provide visualization for spaces higher than ℝ<sup>2</sup> but the examples should demonstrate features 3. and 4. if the solution has them.<code></code></p>