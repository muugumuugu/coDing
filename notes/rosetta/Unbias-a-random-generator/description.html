<link href="/styles/home.css" rel="stylesheet">
<p>Given a weighted one bit generator of random numbers where the probability of a one occuring, <math>P<em>1</math>, is not the same as <math>P</em>0</math>, the probability of a zero occuring, the probability of the occurrence of a one followed by a zero is <math>P<em>1</math> × <math>P</em>0</math>. This is the same as the probability of a zero followed by a one: <math>P<em>0</math> × <math>P</em>1</math>.<code></code>
<code></code>
<code></code>
<br>Task details:<code></code></p>
<ul>
<li>Use your language's random number generator to create a function/method/subroutine/... <code>randN</code> that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive.<code></code></li>
<li>Create a function <code>unbiased</code> that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes.<code></code></li>
<li>For N over its range, generate and show counts of the outputs of randN and unbiased(randN).<code></code>
<code></code>
<br><code></code>
The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.<code></code>
<code></code>
This task is an implementation of <a href="http://en.wikipedia.org/wiki/Randomness_extractor#Von_Neumann_extractor Von Neumann debiasing">http://en.wikipedia.org/wiki/Randomness<em>extractor#Von</em>Neumann_extractor Von Neumann debiasing</a>, first described in a 1951 paper.<code></code>
<br><br><code></code></li>
</ul>