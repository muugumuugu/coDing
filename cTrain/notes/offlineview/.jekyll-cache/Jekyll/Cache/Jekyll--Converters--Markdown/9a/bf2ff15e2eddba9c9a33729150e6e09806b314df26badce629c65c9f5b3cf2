I"7ò<h2 id="what-is-regular-expression">What is Regular Expression?</h2>

<blockquote>
  <p>A regular expression is a group of characters or symbols which is used to find a specific pattern in a text.</p>
</blockquote>

<p>A regular expression is a pattern that is matched against a subject string from
left to right. Regular expressions are used to replace text within a string,
validating forms, extracting a substring from a string based on a pattern match,
and so much more. The term ‚Äúregular expression‚Äù is a mouthful, so you will usually
find the term abbreviated to ‚Äúregex‚Äù or ‚Äúregexp‚Äù.</p>

<p>Imagine you are writing an application and you want to set the rules for when a
user chooses their username. We want to allow the username to contain letters,
numbers, underscores and hyphens. We also want to limit the number of characters
in the username so it does not look ugly. We can use the following regular expression to
validate the username:</p>

<p><br /><br />
The regular expression above can accept the strings <code class="language-plaintext highlighter-rouge">john_doe</code>, <code class="language-plaintext highlighter-rouge">jo-hn_doe</code> and
<code class="language-plaintext highlighter-rouge">john12_as</code>. It does not match <code class="language-plaintext highlighter-rouge">Jo</code> because that string contains an uppercase
letter and also it is too short.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#what-is-regular-expression">What is Regular Expression?</a></li>
  <li><a href="#table-of-contents">Table of Contents</a></li>
  <li><a href="#1-basic-matchers">1. Basic Matchers</a></li>
  <li><a href="#2-meta-characters">2. Meta Characters</a></li>
  <li><a href="#21-the-full-stop">2.1 The Full Stop</a></li>
  <li><a href="#22-character-sets">2.2 Character Sets</a>
    <ul>
      <li><a href="#221-negated-character-sets">2.2.1 Negated Character Sets</a></li>
    </ul>
  </li>
  <li><a href="#23-repetitions">2.3 Repetitions</a>
    <ul>
      <li><a href="#231-the-star">2.3.1 The Star</a></li>
      <li><a href="#232-the-plus">2.3.2 The Plus</a></li>
      <li><a href="#233-the-question-mark">2.3.3 The Question Mark</a></li>
    </ul>
  </li>
  <li><a href="#24-braces">2.4 Braces</a></li>
  <li><a href="#25-capturing-groups">2.5 Capturing Groups</a>
    <ul>
      <li><a href="#251-non-capturing-groups">2.5.1 Non-Capturing Groups</a></li>
    </ul>
  </li>
  <li><a href="#26-alternation">2.6 Alternation</a></li>
  <li><a href="#27-escaping-special-characters">2.7 Escaping Special Characters</a></li>
  <li><a href="#28-anchors">2.8 Anchors</a>
    <ul>
      <li><a href="#281-the-caret">2.8.1 The Caret</a></li>
      <li><a href="#282-the-dollar-sign">2.8.2 The Dollar Sign</a></li>
    </ul>
  </li>
  <li><a href="#3-shorthand-character-sets">3. Shorthand Character Sets</a></li>
  <li><a href="#4-lookarounds">4. Lookarounds</a>
    <ul>
      <li><a href="#41-positive-lookahead">4.1 Positive Lookahead</a></li>
      <li><a href="#42-negative-lookahead">4.2 Negative Lookahead</a></li>
      <li><a href="#43-positive-lookbehind">4.3 Positive Lookbehind</a></li>
      <li><a href="#44-negative-lookbehind">4.4 Negative Lookbehind</a></li>
    </ul>
  </li>
  <li><a href="#5-flags">5. Flags</a>
    <ul>
      <li><a href="#51-case-insensitive">5.1 Case Insensitive</a></li>
      <li><a href="#52-global-search">5.2 Global Search</a></li>
      <li><a href="#53-multiline">5.3 Multiline</a></li>
    </ul>
  </li>
  <li><a href="#6-greedy-vs-lazy-matching">6. Greedy vs Lazy Matching</a></li>
</ul>

<h2 id="1-basic-matchers">1. Basic Matchers</h2>

<p>A regular expression is just a pattern of characters that we use to perform a
search in a text.  For example, the regular expression <code class="language-plaintext highlighter-rouge">the</code> means: the letter
<code class="language-plaintext highlighter-rouge">t</code>, followed by the letter <code class="language-plaintext highlighter-rouge">h</code>, followed by the letter <code class="language-plaintext highlighter-rouge">e</code>.</p>

<pre>
"the" =&gt; The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1">Test the regular expression</a></p>

<p>The regular expression <code class="language-plaintext highlighter-rouge">123</code> matches the string <code class="language-plaintext highlighter-rouge">123</code>. The regular expression is
matched against an input string by comparing each character in the regular
expression to each character in the input string, one after another. Regular
expressions are normally case-sensitive so the regular expression <code class="language-plaintext highlighter-rouge">The</code> would
not match the string <code class="language-plaintext highlighter-rouge">the</code>.</p>

<pre>
"The" =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1">Test the regular expression</a></p>

<h2 id="2-meta-characters">2. Meta Characters</h2>

<p>Meta characters are the building blocks of regular expressions.  Meta
characters do not stand for themselves but instead are interpreted in some
special way. Some meta characters have a special meaning and are written inside
square brackets. The meta characters are as follows:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Meta character</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">.</td>
      <td>Period matches any single character except a line break.</td>
    </tr>
    <tr>
      <td style="text-align: center">[ ]</td>
      <td>Character class. Matches any character contained between the square brackets.</td>
    </tr>
    <tr>
      <td style="text-align: center">[^ ]</td>
      <td>Negated character class. Matches any character that is not contained between the square brackets</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td>Matches 0 or more repetitions of the preceding symbol.</td>
    </tr>
    <tr>
      <td style="text-align: center">+</td>
      <td>Matches 1 or more repetitions of the preceding symbol.</td>
    </tr>
    <tr>
      <td style="text-align: center">?</td>
      <td>Makes the preceding symbol optional.</td>
    </tr>
    <tr>
      <td style="text-align: center">{n,m}</td>
      <td>Braces. Matches at least ‚Äún‚Äù but not more than ‚Äúm‚Äù repetitions of the preceding symbol.</td>
    </tr>
    <tr>
      <td style="text-align: center">(xyz)</td>
      <td>Character group. Matches the characters xyz in that exact order.</td>
    </tr>
    <tr>
      <td style="text-align: center">|</td>
      <td>Alternation. Matches either the characters before or the characters after the symbol.</td>
    </tr>
    <tr>
      <td style="text-align: center">\</td>
      <td>Escapes the next character. This allows you to match reserved characters <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td>
    </tr>
    <tr>
      <td style="text-align: center">^</td>
      <td>Matches the beginning of the input.</td>
    </tr>
    <tr>
      <td style="text-align: center">$</td>
      <td>Matches the end of the input.</td>
    </tr>
  </tbody>
</table>

<h2 id="21-the-full-stop">2.1 The Full Stop</h2>

<p>The full stop <code class="language-plaintext highlighter-rouge">.</code> is the simplest example of a meta character. The meta character <code class="language-plaintext highlighter-rouge">.</code>
matches any single character. It will not match return or newline characters.
For example, the regular expression <code class="language-plaintext highlighter-rouge">.ar</code> means: any character, followed by the
letter <code class="language-plaintext highlighter-rouge">a</code>, followed by the letter <code class="language-plaintext highlighter-rouge">r</code>.</p>

<pre>
".ar" =&gt; The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1">Test the regular expression</a></p>

<h2 id="22-character-sets">2.2 Character Sets</h2>

<p>Character sets are also called character classes. Square brackets are used to
specify character sets. Use a hyphen inside a character set to specify the
characters‚Äô range. The order of the character range inside the square brackets
doesn‚Äôt matter. For example, the regular expression <code class="language-plaintext highlighter-rouge">[Tt]he</code> means: an uppercase
<code class="language-plaintext highlighter-rouge">T</code> or lowercase <code class="language-plaintext highlighter-rouge">t</code>, followed by the letter <code class="language-plaintext highlighter-rouge">h</code>, followed by the letter <code class="language-plaintext highlighter-rouge">e</code>.</p>

<pre>
"[Tt]he" =&gt; <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1">Test the regular expression</a></p>

<p>A period inside a character set, however, means a literal period. The regular
expression <code class="language-plaintext highlighter-rouge">ar[.]</code> means: a lowercase character <code class="language-plaintext highlighter-rouge">a</code>, followed by the letter <code class="language-plaintext highlighter-rouge">r</code>,
followed by a period <code class="language-plaintext highlighter-rouge">.</code> character.</p>

<pre>
"ar[.]" =&gt; A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1">Test the regular expression</a></p>

<h3 id="221-negated-character-sets">2.2.1 Negated Character Sets</h3>

<p>In general, the caret symbol represents the start of the string, but when it is
typed after the opening square bracket it negates the character set. For
example, the regular expression <code class="language-plaintext highlighter-rouge">[^c]ar</code> means: any character except <code class="language-plaintext highlighter-rouge">c</code>,
followed by the character <code class="language-plaintext highlighter-rouge">a</code>, followed by the letter <code class="language-plaintext highlighter-rouge">r</code>.</p>

<pre>
"[^c]ar" =&gt; The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1">Test the regular expression</a></p>

<h2 id="23-repetitions">2.3 Repetitions</h2>

<p>The meta characters <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code> or <code class="language-plaintext highlighter-rouge">?</code> are used to specify how many times a
subpattern can occur. These meta characters act differently in different
situations.</p>

<h3 id="231-the-star">2.3.1 The Star</h3>

<p>The <code class="language-plaintext highlighter-rouge">*</code> symbol matches zero or more repetitions of the preceding matcher. The
regular expression <code class="language-plaintext highlighter-rouge">a*</code> means: zero or more repetitions of the preceding lowercase
character <code class="language-plaintext highlighter-rouge">a</code>. But if it appears after a character set or class then it finds
the repetitions of the whole character set. For example, the regular expression
<code class="language-plaintext highlighter-rouge">[a-z]*</code> means: any number of lowercase letters in a row.</p>

<pre>
"[a-z]*" =&gt; T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1">Test the regular expression</a></p>

<p>The <code class="language-plaintext highlighter-rouge">*</code> symbol can be used with the meta character <code class="language-plaintext highlighter-rouge">.</code> to match any string of
characters <code class="language-plaintext highlighter-rouge">.*</code>. The <code class="language-plaintext highlighter-rouge">*</code> symbol can be used with the whitespace character <code class="language-plaintext highlighter-rouge">\s</code>
to match a string of whitespace characters. For example, the expression
<code class="language-plaintext highlighter-rouge">\s*cat\s*</code> means: zero or more spaces, followed by a lowercase <code class="language-plaintext highlighter-rouge">c</code>,
followed by a lowercase <code class="language-plaintext highlighter-rouge">a</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code>,
followed by zero or more spaces.</p>

<pre>
"\s*cat\s*" =&gt; The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1">Test the regular expression</a></p>

<h3 id="232-the-plus">2.3.2 The Plus</h3>

<p>The <code class="language-plaintext highlighter-rouge">+</code> symbol matches one or more repetitions of the preceding character. For
example, the regular expression <code class="language-plaintext highlighter-rouge">c.+t</code> means: a lowercase <code class="language-plaintext highlighter-rouge">c</code>, followed by
at least one character, followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code>. It needs to be
clarified that<code class="language-plaintext highlighter-rouge">t</code> is the last <code class="language-plaintext highlighter-rouge">t</code> in the sentence.</p>

<pre>
"c.+t" =&gt; The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1">Test the regular expression</a></p>

<h3 id="233-the-question-mark">2.3.3 The Question Mark</h3>

<p>In regular expressions, the meta character <code class="language-plaintext highlighter-rouge">?</code> makes the preceding character
optional. This symbol matches zero or one instance of the preceding character.
For example, the regular expression <code class="language-plaintext highlighter-rouge">[T]?he</code> means: Optional uppercase
<code class="language-plaintext highlighter-rouge">T</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">h</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">e</code>.</p>

<pre>
"[T]he" =&gt; <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1">Test the regular expression</a></p>

<pre>
"[T]?he" =&gt; <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1">Test the regular expression</a></p>

<h2 id="24-braces">2.4 Braces</h2>

<p>In regular expressions, braces (also called quantifiers) are used to
specify the number of times that a character or a group of characters can be
repeated. For example, the regular expression <code class="language-plaintext highlighter-rouge">[0-9]{2,3}</code> means: Match at least
2 digits, but not more than 3, ranging from 0 to 9.</p>

<pre>
"[0-9]{2,3}" =&gt; The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1">Test the regular expression</a></p>

<p>We can leave out the second number. For example, the regular expression
<code class="language-plaintext highlighter-rouge">[0-9]{2,}</code> means: Match 2 or more digits. If we also remove the comma, the
regular expression <code class="language-plaintext highlighter-rouge">[0-9]{3}</code> means: Match exactly 3 digits.</p>

<pre>
"[0-9]{2,}" =&gt; The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1">Test the regular expression</a></p>

<pre>
"[0-9]{3}" =&gt; The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1">Test the regular expression</a></p>

<h2 id="25-capturing-groups">2.5 Capturing Groups</h2>

<p>A capturing group is a group of subpatterns that is written inside parentheses
<code class="language-plaintext highlighter-rouge">(...)</code>. As discussed before, in regular expressions, if we put a quantifier
after a character then it will repeat the preceding character. But if we put a quantifier
after a capturing group then it repeats the whole capturing group. For example,
the regular expression <code class="language-plaintext highlighter-rouge">(ab)*</code> matches zero or more repetitions of the character
‚Äúab‚Äù. We can also use the alternation <code class="language-plaintext highlighter-rouge">|</code> meta character inside a capturing group.
For example, the regular expression <code class="language-plaintext highlighter-rouge">(c|g|p)ar</code> means: a lowercase <code class="language-plaintext highlighter-rouge">c</code>,
<code class="language-plaintext highlighter-rouge">g</code> or <code class="language-plaintext highlighter-rouge">p</code>, followed by <code class="language-plaintext highlighter-rouge">a</code>, followed by <code class="language-plaintext highlighter-rouge">r</code>.</p>

<pre>
"(c|g|p)ar" =&gt; The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1">Test the regular expression</a></p>

<p>Note that capturing groups do not only match, but also capture, the characters for use in
the parent language. The parent language could be Python or JavaScript or virtually any
language that implements regular expressions in a function definition.</p>

<h3 id="251-non-capturing-groups">2.5.1 Non-Capturing Groups</h3>

<p>A non-capturing group is a capturing group that matches the characters but
does not capture the group. A non-capturing group is denoted by a <code class="language-plaintext highlighter-rouge">?</code> followed by a <code class="language-plaintext highlighter-rouge">:</code>
within parentheses <code class="language-plaintext highlighter-rouge">(...)</code>. For example, the regular expression <code class="language-plaintext highlighter-rouge">(?:c|g|p)ar</code> is similar to
<code class="language-plaintext highlighter-rouge">(c|g|p)ar</code> in that it matches the same characters but will not create a capture group.</p>

<pre>
"(?:c|g|p)ar" =&gt; The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/Rm7Me8/1">Test the regular expression</a></p>

<p>Non-capturing groups can come in handy when used in find-and-replace functionality or
when mixed with capturing groups to keep the overview when producing any other kind of output.
See also <a href="#4-lookaround">4. Lookaround</a>.</p>

<h2 id="26-alternation">2.6 Alternation</h2>

<p>In a regular expression, the vertical bar <code class="language-plaintext highlighter-rouge">|</code> is used to define alternation.
Alternation is like an OR statement between multiple expressions. Now, you may be
thinking that character sets and alternation work the same way. But the big
difference between character sets and alternation is that character sets work at the
character level but alternation works at the expression level. For example, the
regular expression <code class="language-plaintext highlighter-rouge">(T|t)he|car</code> means: either (an uppercase <code class="language-plaintext highlighter-rouge">T</code> or a lowercase
<code class="language-plaintext highlighter-rouge">t</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">h</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">e</code>) OR
(a lowercase <code class="language-plaintext highlighter-rouge">c</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">a</code>, followed by
a lowercase <code class="language-plaintext highlighter-rouge">r</code>). Note that I included the parentheses for clarity, to show that either expression
in parentheses can be met and it will match.</p>

<pre>
"(T|t)he|car" =&gt; <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1">Test the regular expression</a></p>

<h2 id="27-escaping-special-characters">2.7 Escaping Special Characters</h2>

<p>A backslash <code class="language-plaintext highlighter-rouge">\</code> is used in regular expressions to escape the next character. This
allows us to include reserved characters such as <code class="language-plaintext highlighter-rouge">{ } [ ] / \ + * . $ ^ | ?</code> as matching characters. To use one of these special character as a matching character, prepend it with <code class="language-plaintext highlighter-rouge">\</code>.</p>

<p>For example, the regular expression <code class="language-plaintext highlighter-rouge">.</code> is used to match any character except a
newline. Now, to match <code class="language-plaintext highlighter-rouge">.</code> in an input string, the regular expression
<code class="language-plaintext highlighter-rouge">(f|c|m)at\.?</code> means: a lowercase <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">c</code> or <code class="language-plaintext highlighter-rouge">m</code>, followed by a lowercase
<code class="language-plaintext highlighter-rouge">a</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code>, followed by an optional <code class="language-plaintext highlighter-rouge">.</code>
character.</p>

<pre>
"(f|c|m)at\.?" =&gt; The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1">Test the regular expression</a></p>

<h2 id="28-anchors">2.8 Anchors</h2>

<p>In regular expressions, we use anchors to check if the matching symbol is the
starting symbol or ending symbol of the input string. Anchors are of two types:
The first type is the caret <code class="language-plaintext highlighter-rouge">^</code> that checks if the matching character is the first
character of the input and the second type is the dollar sign <code class="language-plaintext highlighter-rouge">$</code> which checks if a matching
character is the last character of the input string.</p>

<h3 id="281-the-caret">2.8.1 The Caret</h3>

<p>The caret symbol <code class="language-plaintext highlighter-rouge">^</code> is used to check if a matching character is the first character
of the input string. If we apply the following regular expression <code class="language-plaintext highlighter-rouge">^a</code> (meaning ‚Äòa‚Äô must be
the starting character) to the string <code class="language-plaintext highlighter-rouge">abc</code>, it will match <code class="language-plaintext highlighter-rouge">a</code>. But if we apply
the regular expression <code class="language-plaintext highlighter-rouge">^b</code> to the above string, it will not match anything.
Because in the string <code class="language-plaintext highlighter-rouge">abc</code>, the ‚Äúb‚Äù is not the starting character. Let‚Äôs take a look
at another regular expression <code class="language-plaintext highlighter-rouge">^(T|t)he</code> which means: an uppercase <code class="language-plaintext highlighter-rouge">T</code> or
a lowercase <code class="language-plaintext highlighter-rouge">t</code> must be the first character in the string, followed by a
lowercase <code class="language-plaintext highlighter-rouge">h</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">e</code>.</p>

<pre>
"(T|t)he" =&gt; <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1">Test the regular expression</a></p>

<pre>
"^(T|t)he" =&gt; <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1">Test the regular expression</a></p>

<h3 id="282-the-dollar-sign">2.8.2 The Dollar Sign</h3>

<p>The dollar sign <code class="language-plaintext highlighter-rouge">$</code> is used to check if a matching character is the last character
in the string. For example, the regular expression <code class="language-plaintext highlighter-rouge">(at\.)$</code> means: a
lowercase <code class="language-plaintext highlighter-rouge">a</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code>, followed by a <code class="language-plaintext highlighter-rouge">.</code>
character and the matcher must be at the end of the string.</p>

<pre>
"(at\.)" =&gt; The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1">Test the regular expression</a></p>

<pre>
"(at\.)$" =&gt; The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1">Test the regular expression</a></p>

<h2 id="3-shorthand-character-sets">3. Shorthand Character Sets</h2>

<p>There are a number of convenient shorthands for commonly used character sets/
regular expressions:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Shorthand</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">.</td>
      <td>Any character except new line</td>
    </tr>
    <tr>
      <td style="text-align: center">\w</td>
      <td>Matches alphanumeric characters: <code class="language-plaintext highlighter-rouge">[a-zA-Z0-9_]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">\W</td>
      <td>Matches non-alphanumeric characters: <code class="language-plaintext highlighter-rouge">[^\w]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">\d</td>
      <td>Matches digits: <code class="language-plaintext highlighter-rouge">[0-9]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">\D</td>
      <td>Matches non-digits: <code class="language-plaintext highlighter-rouge">[^\d]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">\s</td>
      <td>Matches whitespace characters: <code class="language-plaintext highlighter-rouge">[\t\n\f\r\p{Z}]</code></td>
    </tr>
    <tr>
      <td style="text-align: center">\S</td>
      <td>Matches non-whitespace characters: <code class="language-plaintext highlighter-rouge">[^\s]</code></td>
    </tr>
  </tbody>
</table>

<h2 id="4-lookarounds">4. Lookarounds</h2>

<p>Lookbehinds and lookaheads (also called lookarounds) are specific types of
<strong><em>non-capturing groups</em></strong> (used to match a pattern but without including it in the matching
list). Lookarounds are used when we a pattern must be
preceded or followed by another pattern. For example, imagine we want to get all
numbers that are preceded by the <code class="language-plaintext highlighter-rouge">$</code> character from the string
<code class="language-plaintext highlighter-rouge">$4.44 and $10.88</code>. We will use the following regular expression <code class="language-plaintext highlighter-rouge">(?&lt;=\$)[0-9\.]*</code>
which means: get all the numbers which contain the <code class="language-plaintext highlighter-rouge">.</code> character and are preceded
by the <code class="language-plaintext highlighter-rouge">$</code> character. These are the lookarounds that are used in regular
expressions:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Symbol</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">?=</td>
      <td>Positive Lookahead</td>
    </tr>
    <tr>
      <td style="text-align: center">?!</td>
      <td>Negative Lookahead</td>
    </tr>
    <tr>
      <td style="text-align: center">?&lt;=</td>
      <td>Positive Lookbehind</td>
    </tr>
    <tr>
      <td style="text-align: center">?&lt;!</td>
      <td>Negative Lookbehind</td>
    </tr>
  </tbody>
</table>

<h3 id="41-positive-lookahead">4.1 Positive Lookahead</h3>

<p>The positive lookahead asserts that the first part of the expression must be
followed by the lookahead expression. The returned match only contains the text
that is matched by the first part of the expression. To define a positive
lookahead, parentheses are used. Within those parentheses, a question mark with
an equals sign is used like this: <code class="language-plaintext highlighter-rouge">(?=...)</code>. The lookahead expressions is written after
the equals sign inside parentheses. For example, the regular expression
<code class="language-plaintext highlighter-rouge">(T|t)he(?=\sfat)</code> means: match either a lowercase <code class="language-plaintext highlighter-rouge">t</code> or an uppercase
 <code class="language-plaintext highlighter-rouge">T</code>, followed by the letter <code class="language-plaintext highlighter-rouge">h</code>, followed by the letter <code class="language-plaintext highlighter-rouge">e</code>. In parentheses we
define a positive lookahead which tells the regular expression engine to match <code class="language-plaintext highlighter-rouge">The</code>
or <code class="language-plaintext highlighter-rouge">the</code> only if it‚Äôs followed by the word <code class="language-plaintext highlighter-rouge">fat</code>.</p>

<pre>
"(T|t)he(?=\sfat)" =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1">Test the regular expression</a></p>

<h3 id="42-negative-lookahead">4.2 Negative Lookahead</h3>

<p>Negative lookaheads are used when we need to get all matches from an input string
that are not followed by a certain pattern. A negative lookahead is written the same way as a
positive lookahead. The only difference is, instead of an equals sign <code class="language-plaintext highlighter-rouge">=</code>, we
use an exclamation mark <code class="language-plaintext highlighter-rouge">!</code> to indicate negation i.e. <code class="language-plaintext highlighter-rouge">(?!...)</code>. Let‚Äôs take a look at the following
regular expression <code class="language-plaintext highlighter-rouge">(T|t)he(?!\sfat)</code> which means: get all <code class="language-plaintext highlighter-rouge">The</code> or <code class="language-plaintext highlighter-rouge">the</code> words
from the input string that are not followed by a space character and the word <code class="language-plaintext highlighter-rouge">fat</code>.</p>

<pre>
"(T|t)he(?!\sfat)" =&gt; The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1">Test the regular expression</a></p>

<h3 id="43-positive-lookbehind">4.3 Positive Lookbehind</h3>

<p>Positive lookbehinds are used to get all the matches that are preceded by a
specific pattern. Positive lookbehinds are written <code class="language-plaintext highlighter-rouge">(?&lt;=...)</code>. For example, the
regular expression <code class="language-plaintext highlighter-rouge">(?&lt;=(T|t)he\s)(fat|mat)</code> means: get all <code class="language-plaintext highlighter-rouge">fat</code> or <code class="language-plaintext highlighter-rouge">mat</code> words
from the input string that come after the word <code class="language-plaintext highlighter-rouge">The</code> or <code class="language-plaintext highlighter-rouge">the</code>.</p>

<pre>
"(?&lt;=(T|t)he\s)(fat|mat)" =&gt; The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/avH165/1">Test the regular expression</a></p>

<h3 id="44-negative-lookbehind">4.4 Negative Lookbehind</h3>

<p>Negative lookbehinds are used to get all the matches that are not preceded by a
specific pattern. Negative lookbehinds are written <code class="language-plaintext highlighter-rouge">(?&lt;!...)</code>. For example, the
regular expression <code class="language-plaintext highlighter-rouge">(?&lt;!(T|t)he\s)(cat)</code> means: get all <code class="language-plaintext highlighter-rouge">cat</code> words from the input
string that are not after the word <code class="language-plaintext highlighter-rouge">The</code> or <code class="language-plaintext highlighter-rouge">the</code>.</p>

<pre>
"(?&lt;!(T|t)he\s)(cat)" =&gt; The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1">Test the regular expression</a></p>

<h2 id="5-flags">5. Flags</h2>

<p>Flags are also called modifiers because they modify the output of a regular
expression. These flags can be used in any order or combination, and are an
integral part of the RegExp.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Flag</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">i</td>
      <td>Case insensitive: Match will be case-insensitive.</td>
    </tr>
    <tr>
      <td style="text-align: center">g</td>
      <td>Global Search: Match all instances, not just the first.</td>
    </tr>
    <tr>
      <td style="text-align: center">m</td>
      <td>Multiline: Anchor meta characters work on each line.</td>
    </tr>
  </tbody>
</table>

<h3 id="51-case-insensitive">5.1 Case Insensitive</h3>

<p>The <code class="language-plaintext highlighter-rouge">i</code> modifier is used to perform case-insensitive matching. For example, the
regular expression <code class="language-plaintext highlighter-rouge">/The/gi</code> means: an uppercase <code class="language-plaintext highlighter-rouge">T</code>, followed by a lowercase
<code class="language-plaintext highlighter-rouge">h</code>, followed by an <code class="language-plaintext highlighter-rouge">e</code>. And at the end of regular expression
the <code class="language-plaintext highlighter-rouge">i</code> flag tells the regular expression engine to ignore the case. As you can
see, we also provided <code class="language-plaintext highlighter-rouge">g</code> flag because we want to search for the pattern in the
whole input string.</p>

<pre>
"The" =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1">Test the regular expression</a></p>

<pre>
"/The/gi" =&gt; <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1">Test the regular expression</a></p>

<h3 id="52-global-search">5.2 Global Search</h3>

<p>The <code class="language-plaintext highlighter-rouge">g</code> modifier is used to perform a global match (finds all matches rather than
stopping after the first match). For example, the regular expression<code class="language-plaintext highlighter-rouge">/.(at)/g</code>
means: any character except a new line, followed by a lowercase <code class="language-plaintext highlighter-rouge">a</code>,
followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code>. Because we provided the <code class="language-plaintext highlighter-rouge">g</code> flag at the end of
the regular expression, it will now find all matches in the input string, not just the first one (which is the default behavior).</p>

<pre>
"/.(at)/" =&gt; The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1">Test the regular expression</a></p>

<pre>
"/.(at)/g" =&gt; The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1">Test the regular expression</a></p>

<h3 id="53-multiline">5.3 Multiline</h3>

<p>The <code class="language-plaintext highlighter-rouge">m</code> modifier is used to perform a multi-line match. As we discussed earlier,
anchors <code class="language-plaintext highlighter-rouge">(^, $)</code> are used to check if a pattern is at the beginning of the input or
the end. But if we want the anchors to work on each line, we use
the <code class="language-plaintext highlighter-rouge">m</code> flag. For example, the regular expression <code class="language-plaintext highlighter-rouge">/at(.)?$/gm</code> means: a lowercase
<code class="language-plaintext highlighter-rouge">a</code>, followed by a lowercase <code class="language-plaintext highlighter-rouge">t</code> and, optionally, anything except
a new line. And because of the <code class="language-plaintext highlighter-rouge">m</code> flag, the regular expression engine now matches patterns
at the end of each line in a string.</p>

<pre>
"/.at(.)?$/" =&gt; The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1">Test the regular expression</a></p>

<pre>
"/.at(.)?$/gm" =&gt; The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1">Test the regular expression</a></p>

<h2 id="6-greedy-vs-lazy-matching">6. Greedy vs Lazy Matching</h2>
<p>By default, a regex will perform a greedy match, which means the match will be as long as
possible. We can use <code class="language-plaintext highlighter-rouge">?</code> to match in a lazy way, which means the match should be as short as possible.</p>

<pre>
"/(.*at)/" =&gt; <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1">Test the regular expression</a></p>

<pre>
"/(.*?at)/" =&gt; <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/2">Test the regular expression</a></p>
:ET