<link href="/styles/home.css" rel="stylesheet">
<p>{{wikipedia|K-d tree}}<code></code>
<a href="Category:Data Structures">Category:Data Structures</a><code></code>
A k-d tree (short for <code>k</code>-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches).<code></code>
k-d trees are a special case of binary space partitioning trees.<code></code>
<code></code>
k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is <code>k, the number of points in the data, N, should be N ≫ 2<sup>k</code></sup>.<code></code>
Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.<code></code>
<code></code>
<code>Task:</code> Construct a k-d tree and perform a nearest neighbor search for two example data sets:<code></code>
<code></code></p>
<h1 id="thewikipediaexampledataofahref235496478172235496478172ac10c">The Wikipedia example data of <a href="(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)">(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)</a>.<code></code></h1>
<h1 id="10003dpointsuniformlydistributedina3dcubec11c">1000 3-d points uniformly distributed in a 3-d cube.<code></code></h1>
<p><code></code>
For the Wikipedia example, find the nearest neighbor to point (9, 2)<code></code>
For the random data, pick a random location and find the nearest neighbor.<code></code>
<code></code>
In addition, instrument your code to count the number of nodes visited in the nearest neighbor search.  Count a node as visited if any field of it is accessed.<code></code>
<code></code>
Output should show the point searched for, the point found<br><code></code>
the distance to the point, and the number of nodes visited.<code></code>
<code></code>
There are variant algorithms for constructing the tree.<code></code>
You can use a simple median strategy or implement something more efficient.<code></code>
Variants of the nearest neighbor search include nearest N neighbors, approximate nearest neighbor, and range searches.<code></code>
You do not have to implement these.<code></code>
The requirement for this task is specifically the nearest single neighbor.<code></code>
Also there are algorithms for inserting, deleting, and balancing k-d trees.<code></code>
These are also not required for the task.<code></code></p>