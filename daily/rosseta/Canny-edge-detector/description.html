<link href="/styles/home.css" rel="stylesheet">
<p><code>Task:</code> Write a program that performs so-called <a href="wp:Canny edge detector|canny edge detection">wp:Canny edge detector|canny edge detection</a> on an image.<code></code>
<code></code>
A possible algorithm consists of the following steps:<code></code>
<code></code></p>
<h1 id="noisereductionmaybeperformedbyahrefwpgaussianblurgaussianfilterwpgaussianblurgaussianfilterac4c"><code>Noise reduction.</code> May be performed by <a href="wp:Gaussian blur|Gaussian filter">wp:Gaussian blur|Gaussian filter</a>.<code></code></h1>
<h1 id="computeintensitygradientmatricesmathg_xmathandmathg_ymathanditsmagnitudemathgmathbrnbspnbspnbspmathgsqrtg_x2g_y2mathbrmaybeperformedbyahrefimageconvolutionconvolutionofanimagewithahrefwpsobeloperatorsobeloperatorsimageconvolutionconvolutionofanimagewpsobeloperatorsobeloperatorsimageconvolutionconvolutionofanimageawithwpsobeloperatorsobeloperatorsac5c">Compute <code>intensity gradient<code>' (matrices <math>G<em>x</math> and <math>G</em>y</math>) and its '</code>magnitude</code> <math>G</math>.<br>&nbsp;&nbsp;&nbsp;<math>G=\sqrt{G<em>x^2+G</em>y^2}</math><br> May be performed by <a href="image convolution|convolution of an image]] with <a href="[wp:Sobel operator|Sobel operators">image convolution|convolution of an image]">[wp:Sobel operator|Sobel operators">image convolution|convolution of an image]</a> with [[wp:Sobel operator|Sobel operators</a>.<code></code></h1>
<h1 id="nonmaximumsuppressionforeachpixelcomputetheorientationofintensitygradientvectormaththetarmatan2leftg_yg_xrightmathtransformanglemaththetamathtooneoffourdirections04590135degreescomputenewarraymathnmathifbrnbspnbspnbspmathgleftp_arightgleftprightgleftp_brightmathbrwheremathpmathisthecurrentpixelmathp_amathandmathp_bmatharethetwoneighbourpixelsinthedirectionofgradientthenmathnpgpmathotherwisemathnp0mathnonzeropixelsinresultingarraycorrespondtolocalmaximaofmathgmathindirectionmaththetapmathc6c"><code>Non-maximum suppression.</code> For each pixel compute the orientation of intensity gradient vector: <math>\theta = {\rm atan2}\left(G<em>y, \, G</em>x\right)</math>. Transform angle <math>\theta</math> to one of four directions: 0, 45, 90, 135 degrees. Compute new array <math>N</math>: if<br>&nbsp;&nbsp;&nbsp;<math>G\left(p<em>a\right)<G\left(p\right)<G\left(p</em>b\right)</math><br>where <math>p</math> is the current pixel, <math>p<em>a</math> and <math>p</em>b</math> are the two neighbour pixels in the direction of gradient, then <math>N(p) = G(p)</math>, otherwise <math>N(p) = 0</math>. Nonzero pixels in resulting array correspond to local maxima of <math>G</math> in direction <math>\theta(p)</math>.<code></code></h1>
<h1 id="tracingedgeswithhysteresisatthisstagetwothresholdsforthevaluesofmathgmathareintroducedmatht_minmathandmatht_maxmathstartingfrompixelswithmathnpgeqslantt_maxmathfindallpathsofpixelswithmathnpgeqslantt_minmathandputthemtotheresultingimagec7c"><code>Tracing edges with hysteresis.</code> At this stage two thresholds for the values of <math>G</math> are introduced: <math>T<em>{min}</math> and <math>T</em>{max}</math>. Starting from pixels with <math>N(p) \geqslant T<em>{max}</math> find all paths of pixels with <math>N(p) \geqslant T</em>{min}</math> and put them to the resulting image.<code></code></h1>