<link href="/styles/home.css" rel="stylesheet">
<p>In strict <a href="wp:Functional programming|functional programming]] and the <a href="[wp:lambda calculus|lambda calculus">wp:Functional programming|functional programming]">[wp:lambda calculus|lambda calculus">wp:Functional programming|functional programming]</a> and the [[wp:lambda calculus|lambda calculus</a>, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.<code></code>
This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.<code></code>
<code></code>
The <a href="http://mvanier.livejournal.com/2897.html Y combinator">http://mvanier.livejournal.com/2897.html Y combinator</a> is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function. The Y combinator is the simplest of the class of such functions, called <a href="wp:Fixed-point combinator|fixed-point combinators">wp:Fixed-point combinator|fixed-point combinators</a>.<code></code>
<code></code>
<code></code>
<br>Task:<code></code>
Define the stateless Y combinator and use it to compute <a href="wp:Factorial|factorials]] and <a href="[wp:Fibonacci number|Fibonacci numbers">wp:Factorial|factorials]">[wp:Fibonacci number|Fibonacci numbers">wp:Factorial|factorials]</a> and [[wp:Fibonacci number|Fibonacci numbers</a> from other stateless functions or lambda expressions.<code></code>
<code></code>
<code></code>
<br>Cf:<code></code></p>
<ul>
<li><a href="http://vimeo.com/45140590 Jim Weirich: Adventures in Functional Programming">http://vimeo.com/45140590 Jim Weirich: Adventures in Functional Programming</a><code></code>
<br><br><code></code></li>
</ul>